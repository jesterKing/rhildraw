<!DOCTYPE html>
<html>
<head>
  <meta property="og:description" content="RhiLDraw, a literate program for importing LEGO models from LDraw files." />
  <meta property="description" content="RhiLDraw, a literate program for importing LEGO models from LDraw files." />
  <meta name="author" content="Nathan 'jesterKing' Letwory">
  <link rel="stylesheet" type="text/css" href="./style.css">
</head>
<body>
<h1>LDraw into Rhino 3D</h1>
<ul>
<li>LDraw file format documentation, see File Format Specification: https://www.ldraw.org/article/218.html</li>
<li>Colors see Colour Definition Language Extension: https://www.ldraw.org/article/299.html</li>
</ul>
<p>LEGO models can be described in the LDraw format. The file format was developed
by James Jessiman in 1995. Since then this has become a defacto standard for
creating LEGO models on computers.</p>
<p>This program <code>rhildraw</code> is a simple importer of LDraw files. A model can be
described by one or more files. We'll get to the details of these files as we go
on our journey to implementing the importer.</p>
<h2>Overview of the program</h2>
<p>The following diagram shows the main structure of the script</p>
<pre class="mermaid">
flowchart TD
    subgraph init
    A[[Initialization]]
    B[Read file]
    end
    subgraph geom [Read Module]
    direction LR
    C[[Handle commands]]
    D[[Add part geometry]]
    E[[Create block definition]]
    end
    A --> B
    B --> geom
    C --> D
    D --> C
    D --> E

</pre><h2>Initialization</h2>
<p>We will be using a couple of dictionaries to keep track of files, materials and
so on. These will make finding data easier as the command to import another file
uses the file name as the key either without or with a parent folder prepended.</p>
<p>Dictionaries for the follow data are used:</p>
<ul>
<li><code>vfiles</code>: dictionary to file representations. Each file will be represented
twice. Once with just the file name and once with parent folder prepended
<code>parent/file.dat</code></li>
<li><code>idefs</code>: dictionary holding all block definitions. The block definiton name is
the key. Block definition names are part file names without the extension. The
block definitions are the values. The corresponding <code>RhinoCommon</code> class is
<code>InstanceDefinition</code>.</li>
<li><code>materials</code>: dictionary containing LEGO colors as <code>RenderMaterial</code>s. The color
code is the key. Colors are materialized as <code>RenderMaterial</code> only when
actually needed.</li>
</ul>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;initialize global variables&gt;&gt;= </div>
<div class="code">
<pre><code>

vfiles: Mapping[<span class="hljs-built_in">str</span>, LDrawFile]= <span class="hljs-built_in">dict</span>()
idefs : Mapping[<span class="hljs-built_in">str</span>, InstanceDefinition]= <span class="hljs-built_in">dict</span>()
materials : Mapping[<span class="hljs-built_in">str</span>, LDrawMaterial]= <span class="hljs-built_in">dict</span>()
vertidx = <span class="hljs-number">0</span>
</code></pre>

</div>
</div><h3>Preparing the virtual file system</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to prepare virtual files&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_parts_dictionary</span>():
    <span class="hljs-keyword">global</span> lib_path
    library_path : Path = Path(lib_path)
    library_path_net : DirectoryInfo = DirectoryInfo(lib_path)
    all_parts_net = library_path_net.EnumerateFiles(<span class="hljs-string">&quot;*&quot;</span>, SearchOption.AllDirectories)
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> all_parts_net:
        fn = Path(p.FullName)
        ldrawfile = LDrawFile(fn)
        vfiles[ldrawfile.name] = ldrawfile
        vfiles[ldrawfile.pname] = ldrawfile
</code></pre>

</div>
</div><h3>Fetch from the virtual file system</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get LDrawFile instance&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ldraw_file</span>(<span class="hljs-params">part_name : <span class="hljs-built_in">str</span></span>) -&gt; LDrawFile:
    <span class="hljs-keyword">global</span> vfiles

    part_name = part_name.replace(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;\\&#x27;</span>)

    <span class="hljs-keyword">if</span> part_name <span class="hljs-keyword">in</span> vfiles:
        <span class="hljs-keyword">return</span> vfiles[part_name]

    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">f&quot;Part file not found: <span class="hljs-subst">{part_name}</span>&quot;</span>)
</code></pre>

</div>
</div><h3>Add a virtual file to the virtual file system</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to add a virtual file&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_virtual_file</span>(<span class="hljs-params">model : Path, filename : <span class="hljs-built_in">str</span>, data : <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>):
    virtual_file_path = model.parent / <span class="hljs-string">&#x27;virtual&#x27;</span> / filename
    virtual_file = LDrawFile(virtual_file_path, data)
    vfiles[virtual_file.name] = virtual_file
    vfiles[virtual_file.pname] = virtual_file
</code></pre>

</div>
</div><h3>Preparing the instance definition map</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to prepare instance definitions&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_idefs_dictionary</span>():
    <span class="hljs-keyword">for</span> idef <span class="hljs-keyword">in</span> sc.doc.InstanceDefinitions:
        idefs[idef.Name] = idef
</code></pre>

</div>
</div><h3>Update the instance definition map</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to update instance definitions&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_idefs_dictionary</span>(<span class="hljs-params">part_name</span>):
    idef_part_name = clean_name(part_name)
    idef = sc.doc.InstanceDefinitions.Find(idef_part_name)
    <span class="hljs-keyword">if</span> idef:
        idefs[idef_part_name] = idef
        <span class="hljs-keyword">return</span> idef
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>

</div>
</div><h3>Fetching instance definition</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get InstanceDefinition instance&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_part_idef</span>(<span class="hljs-params">prt</span>):
    p = Path(prt)
    pname = clean_name(p.name)
    <span class="hljs-keyword">if</span> pname <span class="hljs-keyword">in</span> idefs:
        <span class="hljs-keyword">return</span> idefs[pname]

    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>

</div>
</div><h3>Reading color definitions</h3>
<p>Colors are defined just like parts and assemblies. Line type 0 is used through
the Colour Definition Language Extension
(<a href="https://www.ldraw.org/article/299">specification</a>).</p>
<p>For this script we'll be using the colors defined in <code>LDConfig.ldr</code> from the
LDraw complete library, although there are alternatives available. Technically
the file with standard color definitions contains the following line in its
header:</p>
<p><code>0 !LDRAW_ORG Configuration UPDATE YYYY-MM-DD</code></p>
<p>But we'll forgo this check and just assume the file we specify is the correct
file.</p>
<p>Preparing the colors means preparing color data for materials so that is what
we'll be doing.</p>
<p>We need just one simple method to set up the <code>materials</code> dictionary that will
contain all the defined colors, and that is the <code>&lt;&lt;method to load colors&gt;&gt;</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;initialize color definitions&gt;&gt;= </div>
<div class="code">
<pre><code><span class="literate-tag-name">&lt;&lt;method to load colors&gt;&gt;</span>
</code></pre>

</div>
</div><p>To load the colors we just need to get the <code>LDrawFile</code> instance for
<code>LDConfig.ldr</code> and pull out the commands. Then we loop over all the commands and
handle those that start with the required <code>0 !COLOUR</code> string. Again we assume
that a command is well-formed. For each color command we
<code>&lt;&lt;read color properties from command&gt;&gt;</code>, create an instance of <code>LDrawMaterial</code>
and add it to the <code>materials</code> dictionary.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to load colors&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_colors</span>():
    <span class="literate-tag-name">&lt;&lt;load color commands&gt;&gt;</span>
    COLOR_CMD = <span class="hljs-string">&quot;0 !COLOUR &quot;</span>
    TO_REMOVE = <span class="hljs-string">&quot;0 !&quot;</span>
    <span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> cmds:
        <span class="hljs-keyword">if</span> cmd.startswith(COLOR_CMD):
            <span class="literate-tag-name">&lt;&lt;read color properties from command&gt;&gt;</span>
            <span class="literate-tag-name">&lt;&lt;create material and save to dictionary&gt;&gt;</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Colors read&quot;</span>)
</code></pre>

</div>
</div><p>To <code>&lt;&lt;load color commands&gt;&gt;</code> we simple get the <code>LDrawFile</code> instance for
<code>LDConfig.ldr</code> and use <code>get_commands()</code> on that.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;load color commands&gt;&gt;= </div>
<div class="code">
<pre><code>colorldr = get_ldraw_file(<span class="hljs-string">&quot;LDConfig.ldr&quot;</span>)
cmds = colorldr.get_commands()
</code></pre>

</div>
</div><p>Then for each line we clean up the part we're not using (<code>0 !</code>). Most keys have
values, but for finishes there is a little snag. Most of the finishes, <code>CHROME</code>,
<code>PEARLESCENT</code>, <code>RUBBER</code>, <code>MATTE_METALLIC</code> and <code>METAL</code> when specified make this
an odd list. To even that out we will add a <code>dummy</code> value to the list, so we can
simple iterate over the list in pairs and generate a dictionary out of it.
Eventually we'll be able to properly handle finishes. Perhaps <code>MATERIAL SPECKLE</code>
and <code>MATERIAL GLITTER</code> with the use of some good procedural texturing.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;read color properties from command&gt;&gt;= </div>
<div class="code">
<pre><code>properties = <span class="hljs-built_in">dict</span>()
cmd = cmd[<span class="hljs-built_in">len</span>(TO_REMOVE):]
cmd_split = cmd.split()
<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cmd_split) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
    cmd_split.append(<span class="hljs-string">&#x27;dummy&#x27;</span>)
keyvalue_count = <span class="hljs-built_in">len</span>(cmd_split) // <span class="hljs-number">2</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, keyvalue_count*<span class="hljs-number">2</span>, <span class="hljs-number">2</span>):
    properties[cmd_split[i]] = cmd_split[i+<span class="hljs-number">1</span>]
</code></pre>

</div>
</div><p>With the properties now converted to a dictionary we can instantiate an
<code>LDrawMaterial</code> and add it to the main <code>materials</code> dictionary with the <code>CODE</code>
value as key. This key we can later use during handling of other commands that
specify a key code to find the correct entry.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create material and save to dictionary&gt;&gt;= </div>
<div class="code">
<pre><code>ldraw_material = LDrawMaterial(properties)
materials[properties[<span class="hljs-string">&quot;CODE&quot;</span>]] = ldraw_material
</code></pre>

</div>
</div><h3>LDrawMaterial class</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;LDraw material class&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">LDrawMaterial</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, props</span>):
        self.properties = props
        self.name = props[<span class="hljs-string">&quot;COLOUR&quot;</span>]
        self.render_material = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_color4f</span>(<span class="hljs-params">self, colstr</span>):
        colstr = colstr[<span class="hljs-number">1</span>:]
        r = <span class="hljs-built_in">int</span>(colstr[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>], <span class="hljs-number">16</span>) / <span class="hljs-number">255.0</span>
        g = <span class="hljs-built_in">int</span>(colstr[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>], <span class="hljs-number">16</span>) / <span class="hljs-number">255.0</span>
        b = <span class="hljs-built_in">int</span>(colstr[<span class="hljs-number">4</span>:<span class="hljs-number">6</span>], <span class="hljs-number">16</span>) / <span class="hljs-number">255.0</span>
        <span class="hljs-keyword">return</span> Color4f(r, g, b, <span class="hljs-number">1.0</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_alpha</span>(<span class="hljs-params">self, alphastr</span>):
        alpha = <span class="hljs-number">1.0</span> - (<span class="hljs-built_in">float</span>(alphastr) / <span class="hljs-number">255.0</span>)
        <span class="hljs-keyword">return</span> alpha

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_render_material</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.render_material == <span class="hljs-literal">None</span>:

            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">f&quot;Material non-existant: <span class="hljs-subst">{self.name}</span>&quot;</span>)
        <span class="hljs-keyword">return</span> self.render_material

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_render_material</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> rm <span class="hljs-keyword">in</span> sc.doc.RenderMaterials:
            <span class="hljs-keyword">if</span> rm.Name == self.name:
                self.render_material = rm
                <span class="hljs-keyword">return</span>
        pbr_rm = RenderContentType.NewContentFromTypeId(pbr_guid)

        _basecolor = self._get_color4f(self.properties[<span class="hljs-string">&quot;VALUE&quot;</span>])

        _roughness = <span class="hljs-number">0.2</span>
        _metallic = <span class="hljs-number">0.0</span>
        _opacity = <span class="hljs-number">1.0</span>

        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ALPHA&quot;</span> <span class="hljs-keyword">in</span> self.properties:
            _opacity = self._alpha(self.properties[<span class="hljs-string">&quot;ALPHA&quot;</span>])
            _roughness = <span class="hljs-number">0.03</span>

        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;METAL&quot;</span> <span class="hljs-keyword">in</span> self.properties <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;CHROME&quot;</span> <span class="hljs-keyword">in</span> self.properties:
            _metallic = <span class="hljs-number">1.0</span>
            _roughness = <span class="hljs-number">0.03</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;MATTE_METALLIC&quot;</span> <span class="hljs-keyword">in</span> self.properties:
            _metallic = <span class="hljs-number">1.0</span>
            _roughness = <span class="hljs-number">0.3</span>

        pbr_rm.SetParameter(PbrNames.BaseColor, _basecolor)
        pbr_rm.SetParameter(PbrNames.Opacity, _opacity)
        pbr_rm.SetParameter(PbrNames.Metallic, _metallic)
        pbr_rm.SetParameter(PbrNames.Roughness, _roughness)

        pbr_rm.Name = self.name
        self.render_material = pbr_rm
        sc.doc.RenderMaterials.Add(pbr_rm)

</code></pre>

</div>
</div><p>The content GUID used to create Physically Based Material instances is
short-handed in <code>pbr_guid</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;initialize global variables&gt;&gt;=+ </div>
<div class="code">
<pre><code>pbr_guid = ContentUuids.PhysicallyBasedMaterialType
</code></pre>

</div>
</div><h2>Reading files</h2>
<p>All LDraw files consist of lines where each line is of a certain line type. Each
line type denotes a command. All LDraw files have these line types, so it is
easy to parse them.</p>
<p>LDraw files have the extenions <code>.mpd</code>, <code>.ldr</code> and <code>.dat</code>. These extensions are
typically used for files with specific usage although from just the contents it
doesn't really matter.</p>
<p>However, the following are well-established conventions. The <code>.dat</code> file is used
to define geometry of parts and subparts. The <code>.ldr</code> files often contain
commands to load parts, they express assemblies or models. The <code>.mpd</code> is a form
of multi-part document, where in one file several files are combined.</p>
<p>In our script we represent LDraw files with the class <code>LDrawFile</code>. The class
itself is very simple. It has only a method for
<code>&lt;&lt;initialization of LDrawFile&gt;&gt;</code> and a method to
<code>&lt;&lt;get commands from LDrawFile&gt;&gt;</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;LDrawFile class&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">LDrawFile</span>:
    <span class="literate-tag-name">&lt;&lt;initialization of LDrawFile&gt;&gt;</span>
    <span class="literate-tag-name">&lt;&lt;get commands from LDrawFile&gt;&gt;</span>
    <span class="literate-tag-name">&lt;&lt;method to determine if LDrawFile contains poly commands&gt;&gt;</span>

</code></pre>

</div>
</div><p>Instantiation of an <code>LDrawFile</code> instance takes a required parameter <code>path</code>. From
this <code>Path</code> instance the file name, suffix and filename with parent are
extracted.</p>
<p>If the contents of the file are known during instancing the data can be passed
in as a list of strings.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;initialization of LDrawFile&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, path : Path, data : <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = []</span>):
    self.commands = data
    self.path = path
    self.name = path.name
    self.suffix = path.suffix
    self.pname = <span class="hljs-string">f&quot;<span class="hljs-subst">{path.parent.name}</span>\\<span class="hljs-subst">{self.name}</span>&quot;</span>
</code></pre>

</div>
</div><p>For most files the contents will not be known in advance. When retrieving the
contents the file gets lazily loaded and the contents cached in case this
particular file is used again in a model.</p>
<p>Files are to be read in as UTF-8 files. At some point it would probably be good
to perhaps support falling back to encodings of old files.</p>
<p>Reading of the file also strips already out empty lines.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;get commands from LDrawFile&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_commands</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.commands)==<span class="hljs-number">0</span>:
        <span class="hljs-keyword">with</span> self.path.<span class="hljs-built_in">open</span>(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:
            cmds = [l.strip() <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> f.readlines()]
            cmds = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cmds <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) &gt; <span class="hljs-number">0</span>]
            self.commands = cmds

    <span class="hljs-keyword">return</span> self.commands
</code></pre>

</div>
</div><div class="codefragment">
<div class="fragmentname">&lt;&lt;method to determine if LDrawFile contains poly commands&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">contains_poly_commands</span>(<span class="hljs-params">self</span>):
    cmds = self.get_commands()
    <span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> cmds:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cmd) == <span class="hljs-number">0</span>: <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">if</span> cmd[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>

</div>
</div><h2>Line types</h2>
<p>The heart of the LDraw specification revolves around line types. The
specification essentially is a collection of lines whereby the first character
of the line tells us what kind of operation has to happen.</p>
<p>For now we'll keep the importer simple and go where the path is easiest. We'll
implement mainly line types 3, 4 and 1, with a smidge of 0 through the color
definition language. Eventually we may want to include also 2 and 5 lines, but
for just importing complete models for set dressing and rendering purposes this
should get us going.</p>
<p>Line types 3 and 4 add polygon methods, triangles and quads respectively.</p>
<h2>Adding polygons</h2>
<p>Handling line types 3 and 4 means adding either a triangle or a quad. The form
of line types 3 and 4 are similar. A line type three starts with the number <code>3</code>
followed by a color code and three triplets of values that are either integers
or floating point. For both line types we ignore the color code as we'll be
using the color codes defined on line type 1 commands. But we'll get into that
later.</p>
<p>The line type four has a similar format, starting with number <code>4</code>, the color
code and then <em>four</em> triplets of values.</p>
<p>From the start number we parse how many triplets - vertices we'll be handling.
This is the first character of the command string.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;parse vertex count&gt;&gt;= </div>
<div class="code">
<pre><code>vertices = <span class="hljs-built_in">int</span>(cmd[<span class="hljs-number">0</span>])
elements = vertices * stride
to = start + vertices * stride
</code></pre>

</div>
</div><p>Each triplet is a coordinate in the polygon. The order in which the triplets are
presented is also the vertex order.</p>
<p>The format also has a facility to tell the winding for polygons, but we ignore
that here. We'll be using simple CW winding.</p>
<p>Each line has all their elements separated by white space. A simple split will
suffice. We'll take only all parts after the color code. Parse all elements as
floats, since they form vertices. If any element fails to parse as a float we'll
skip adding this as a polygon.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;parse vertices&gt;&gt;= </div>
<div class="code">
<pre><code>d = cmd.split()[start:to]
<span class="hljs-keyword">try</span>:
    d = [<span class="hljs-built_in">float</span>(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> d]
<span class="hljs-keyword">except</span> Exception:
    <span class="hljs-keyword">return</span>
</code></pre>

</div>
</div><p>With all numbers parsed we can add them as vertices to the mesh, increasing the
<code>vertidx</code> count for each item.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;add vertices to mesh&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, elements, stride):
    V = apply_transforms(d[i:i+stride], xforms)
    m.Vertices.Add(*V)
    vertidx = vertidx + <span class="hljs-number">1</span>
</code></pre>

</div>
</div><p>With all vertices added and <code>vertidx</code> adjusted we can now add the face
definition for either the triangle or the quad.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;add face to mesh&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">if</span> vertices == <span class="hljs-number">4</span>:
    m.Faces.AddFace(vertidx - <span class="hljs-number">4</span>, vertidx - <span class="hljs-number">3</span>, vertidx - <span class="hljs-number">2</span>, vertidx - <span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> vertices == <span class="hljs-number">3</span>:
    m.Faces.AddFace(vertidx - <span class="hljs-number">3</span>, vertidx - <span class="hljs-number">2</span>, vertidx - <span class="hljs-number">1</span>)
</code></pre>

</div>
</div><p>To bring it all together we can say that to add a polygon from a command string
we first <code>&lt;&lt;parse vertex count&gt;&gt;</code> and <code>&lt;&lt;parse vertices&gt;&gt;</code>, then
<code>&lt;&lt;add vertices to mesh&gt;&gt;</code> followed by the final step <code>&lt;&lt;add face to mesh&gt;&gt;</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;add polygon method&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_poly</span>(<span class="hljs-params">m : Mesh, cmd : <span class="hljs-built_in">str</span>, xforms : <span class="hljs-built_in">list</span></span>):
    <span class="hljs-keyword">global</span> vertidx
    stride = <span class="hljs-number">3</span>
    start = <span class="hljs-number">2</span>
    <span class="literate-tag-name">&lt;&lt;parse vertex count&gt;&gt;</span>
    <span class="literate-tag-name">&lt;&lt;parse vertices&gt;&gt;</span>
    <span class="literate-tag-name">&lt;&lt;add vertices to mesh&gt;&gt;</span>
    <span class="literate-tag-name">&lt;&lt;add face to mesh&gt;&gt;</span>
</code></pre>

</div>
</div><h2>Loading a model</h2>
<pre class="mermaid">
flowchart
    A[Model]
    B[Assembly]
    C[Geometry]

    A --> B
    B --> B
    B --> C
    C --> C

</pre><div class="codefragment">
<div class="fragmentname">&lt;&lt;method to load a complete model&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_model</span>(<span class="hljs-params">model : LDrawFile</span>):
    lines = model.get_commands()

    FILE_START = <span class="hljs-string">&#x27;0 FILE &#x27;</span>
    first_file = <span class="hljs-string">&#x27;&#x27;</span>
    <span class="hljs-keyword">if</span> model.suffix.lower() == <span class="hljs-string">&#x27;.mpd&#x27;</span>:
        
        cur_file = <span class="hljs-string">&#x27;&#x27;</span>
        file_data = []
        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines:
            <span class="hljs-keyword">if</span> l.startswith(FILE_START):
                <span class="hljs-keyword">if</span> cur_file != <span class="hljs-string">&#x27;&#x27;</span>:
                    add_virtual_file(model.path, cur_file, file_data)
                <span class="hljs-keyword">if</span> cur_file == <span class="hljs-string">&#x27;&#x27;</span>:
                    first_file = l[<span class="hljs-built_in">len</span>(FILE_START):]
                cur_file = l[<span class="hljs-built_in">len</span>(FILE_START):]
                file_data = [l]
            <span class="hljs-keyword">else</span>:
                file_data.append(l)
        add_virtual_file(model.path, cur_file, file_data) 
    start_part = get_ldraw_file(first_file)

    load_assembly(start_part, [rhino_orient])
</code></pre>

</div>
</div><h3>Loading assembly</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to load an assembly&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_assembly</span>(<span class="hljs-params">part : LDrawFile, xforms : <span class="hljs-built_in">list</span></span>):
    cmds = []
    cmds = part.get_commands()

    cmds = [l <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> cmds <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l)&gt;<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> cmds:
        <span class="hljs-keyword">if</span> cmd.startswith(<span class="hljs-string">&#x27;1&#x27;</span>):
            d = cmd.split()
            color_code = d[<span class="hljs-number">1</span>]
            materials[color_code].create_render_material()
            rm = materials[color_code].render_material
            xform = LDrawXform(cmd)
            prt = <span class="hljs-string">&#x27; &#x27;</span>.join(d[<span class="hljs-number">14</span>:])
            _xforms = xforms[:] + [xform]

            obattr = ObjectAttributes()
            obattr.Name = clean_name(prt)
            obattr.Visible = <span class="hljs-literal">True</span>
            obattr.MaterialSource = ObjectMaterialSource.MaterialFromObject
            obattr.RenderMaterial = rm

            <span class="hljs-keyword">if</span> prt.lower().endswith(<span class="hljs-string">&quot;.ldr&quot;</span>):
                ldr_file = get_ldraw_file(prt)
                <span class="hljs-keyword">if</span> ldr_file.contains_poly_commands():
                    add_geometry(prt)
                    idef = update_idefs_dictionary(prt)
                    <span class="hljs-keyword">if</span> idef != <span class="hljs-literal">None</span>:
                        xform = collate_transforms(_xforms)
                        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Couldn&#x27;t add part <span class="hljs-subst">{prt}</span>&quot;</span>)
                <span class="hljs-keyword">else</span>:
                    load_assembly(ldr_file, _xforms)
            <span class="hljs-keyword">else</span>:
                idef = get_part_idef(prt)
                xform = collate_transforms(_xforms)
                <span class="hljs-keyword">if</span> idef != <span class="hljs-literal">None</span>:
                    sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                <span class="hljs-keyword">else</span>:
                    add_geometry(prt)
                    idef = update_idefs_dictionary(prt)
                    <span class="hljs-keyword">if</span> idef != <span class="hljs-literal">None</span>:
                        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Failed to add part <span class="hljs-subst">{prt}</span>&quot;</span>)

            refresh()
</code></pre>

</div>
</div><h3>Loading geometry</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;methods to load geometry&gt;&gt;= </div>
<div class="code">
<pre><code>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_geomety_from_file</span>(<span class="hljs-params">part : LDrawFile, m : Mesh, xforms : <span class="hljs-built_in">list</span></span>):
    cmds = part.get_commands()
    <span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> cmds:
        <span class="hljs-keyword">if</span> cmd.startswith(<span class="hljs-string">&#x27;1&#x27;</span>):
            d = cmd.split()
            xform = LDrawXform(cmd)
            prt = <span class="hljs-string">&#x27; &#x27;</span>.join(d[<span class="hljs-number">14</span>:])
            _xforms = [xform] + xforms[:]
            <span class="hljs-keyword">try</span>:
                part_file = get_ldraw_file(prt)
            <span class="hljs-keyword">except</span> Exception:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\tERR: Failed getting part <span class="hljs-subst">{prt}</span>, skipping&quot;</span>)
                <span class="hljs-keyword">continue</span>
            load_geomety_from_file(part_file, m, _xforms)
        <span class="hljs-keyword">elif</span> cmd.startswith(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-keyword">or</span> cmd.startswith(<span class="hljs-string">&#x27;4&#x27;</span>):
            add_poly(m, cmd, xforms)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">add_geometry</span>(<span class="hljs-params">part_name : <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">global</span> vertidx
    vertidx = <span class="hljs-number">0</span>
    name = clean_name(part_name)

    existing_idef = sc.doc.InstanceDefinitions.Find(name)
    <span class="hljs-keyword">if</span> existing_idef:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\tSkipping <span class="hljs-subst">{part_name}</span>, instance already created&quot;</span>)
        <span class="hljs-keyword">return</span>
    tmesh = Mesh()
    mesh = Mesh()
    obattr = ObjectAttributes()

    obattr.Name = name
    obattr.Visible = <span class="hljs-literal">True</span>
    obattr.MaterialSource = ObjectMaterialSource.MaterialFromParent

    ldraw_file = get_ldraw_file(part_name)
    load_geomety_from_file(ldraw_file, tmesh, [id_xform])
    tmesh.Normals.ComputeNormals()
    tmesh.Compact()

    meshes = tmesh.SplitDisjointPieces()
    <span class="hljs-keyword">for</span> submesh <span class="hljs-keyword">in</span> meshes:
        submesh.Weld(rhmath.ToRadians(<span class="hljs-number">60</span>))
        submesh.UnifyNormals()
        mesh.Append(submesh)
    mesh.Weld(rhmath.ToRadians(<span class="hljs-number">60</span>))
    mesh.Compact()

    <span class="hljs-keyword">if</span> mesh.Vertices.Count &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> mesh.Faces.Count &gt; <span class="hljs-number">0</span>:
        sc.doc.InstanceDefinitions.Add(obattr.Name, <span class="hljs-string">&quot;&quot;</span>, Point3f.Origin, mesh, obattr)

</code></pre>

</div>
</div><h3>LDrawXform class</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;LDrawXform class&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">LDrawXform</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data : <span class="hljs-built_in">str</span></span>):
        data = data.strip()
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">try</span>:
                d = [<span class="hljs-built_in">float</span>(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> data.split()[<span class="hljs-number">2</span>:<span class="hljs-number">14</span>]]
                self.x = d[<span class="hljs-number">0</span>]
                self.y = d[<span class="hljs-number">1</span>]
                self.z = d[<span class="hljs-number">2</span>]
                self.a = d[<span class="hljs-number">3</span>]
                self.b = d[<span class="hljs-number">4</span>]
                self.c = d[<span class="hljs-number">5</span>]
                self.d = d[<span class="hljs-number">6</span>]
                self.e = d[<span class="hljs-number">7</span>]
                self.f = d[<span class="hljs-number">8</span>]
                self.g = d[<span class="hljs-number">9</span>]
                self.h = d[<span class="hljs-number">10</span>]
                self.i = d[<span class="hljs-number">11</span>]
                xform : Transform = Transform.Identity
                xform.M00 = self.a
                xform.M01 = self.b
                xform.M02 = self.c
                xform.M03 = self.x
                xform.M10 = self.d
                xform.M11 = self.e
                xform.M12 = self.f
                xform.M13 = self.y
                xform.M20 = self.g
                xform.M21 = self.h
                xform.M22 = self.i
                xform.M23 = self.z
                self.xform = xform
            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
                self.xform = Transform.Identity
        <span class="hljs-keyword">else</span>:
            self.xform = Transform.Identity

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_xform</span>(<span class="hljs-params">self, xform</span>):
        self.xform = xform

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform_point</span>(<span class="hljs-params">self, u : <span class="hljs-built_in">float</span>, v : <span class="hljs-built_in">float</span>, w : <span class="hljs-built_in">float</span></span>):
        p = Point3f(u, v, w)
        p.Transform(self.xform)
        <span class="hljs-keyword">return</span> [p.X, p.Y, p.Z]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_xform</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.xform

rhino_orient = LDrawXform(<span class="hljs-string">&quot;&quot;</span>)
rhino_orient.set_xform(
    Transform.Rotation(
        rhmath.ToRadians(-<span class="hljs-number">90.0</span>),
        Vector3f.XAxis,
        Point3f.Origin
    )
)
id_xform = LDrawXform(<span class="hljs-string">&quot;&quot;</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_transforms</span>(<span class="hljs-params">v, xforms</span>):
    <span class="hljs-keyword">for</span> xform <span class="hljs-keyword">in</span> xforms:
        v = xform.transform_point(*v)
    <span class="hljs-keyword">return</span> v

<span class="hljs-keyword">def</span> <span class="hljs-title function_">collate_transforms</span>(<span class="hljs-params">xforms</span>):
   xform = Transform.Identity
   <span class="hljs-keyword">for</span> _xform <span class="hljs-keyword">in</span> xforms:
       xform = xform * _xform.get_xform()

   <span class="hljs-keyword">return</span> xform

</code></pre>

</div>
</div><h2>Misc helper methods</h2>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;misc helper methods&gt;&gt;= </div>
<div class="code">
<pre><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">refresh</span>():
    sc.doc.Views.Redraw()
    Rhino.RhinoApp.Wait()


<span class="hljs-keyword">def</span> <span class="hljs-title function_">clean_name</span>(<span class="hljs-params">part_name</span>):
    part_name = part_name.removesuffix(<span class="hljs-string">&quot;.dat&quot;</span>)
    part_name = part_name.removesuffix(<span class="hljs-string">&quot;.DAT&quot;</span>)
    part_name = part_name.removesuffix(<span class="hljs-string">&quot;.ldr&quot;</span>)
    part_name = part_name.removesuffix(<span class="hljs-string">&quot;.LDR&quot;</span>)
    <span class="hljs-keyword">return</span> part_name
</code></pre>

</div>
</div><h2>Pulling all parts together</h2>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;the whole script.*&gt;&gt;= ./src/rhildraw.py $</div>
<div class="code">
<pre><code><span class="hljs-keyword">import</span> scriptcontext <span class="hljs-keyword">as</span> sc
<span class="hljs-keyword">import</span> math

<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Mapping, <span class="hljs-type">List</span>

<span class="hljs-keyword">import</span> Rhino

<span class="hljs-keyword">from</span> Rhino.Geometry <span class="hljs-keyword">import</span> Transform, Mesh, Vector3f, Point3f
<span class="hljs-keyword">from</span> Rhino.Display <span class="hljs-keyword">import</span> Color4f
<span class="hljs-keyword">from</span> Rhino.DocObjects <span class="hljs-keyword">import</span> ObjectAttributes, ObjectMaterialSource
<span class="hljs-keyword">from</span> Rhino.DocObjects <span class="hljs-keyword">import</span> InstanceDefinition
<span class="hljs-keyword">from</span> Rhino.Render <span class="hljs-keyword">import</span> ChildSlotNames, ContentUuids, RenderContentType

PbrNames = ChildSlotNames.PhysicallyBased
rhmath = Rhino.RhinoMath

<span class="hljs-keyword">from</span> System.IO <span class="hljs-keyword">import</span> DirectoryInfo, Directory, File, FileInfo
<span class="hljs-keyword">from</span> System.IO <span class="hljs-keyword">import</span> EnumerationOptions, SearchOption

<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path

<span class="literate-tag-name">&lt;&lt;LDrawFile class&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;LDraw material class&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;LDrawXform class&gt;&gt;</span>

<span class="literate-tag-name">&lt;&lt;initialize global variables&gt;&gt;</span>

<span class="literate-tag-name">&lt;&lt;misc helper methods&gt;&gt;</span>

<span class="literate-tag-name">&lt;&lt;method to prepare virtual files&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;method to add a virtual file&gt;&gt;</span>

<span class="literate-tag-name">&lt;&lt;method to prepare instance definitions&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;method to update instance definitions&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;method to get InstanceDefinition instance&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;method to get LDrawFile instance&gt;&gt;</span>

<span class="literate-tag-name">&lt;&lt;add polygon method&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;methods to load geometry&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;method to load an assembly&gt;&gt;</span>
<span class="literate-tag-name">&lt;&lt;method to load a complete model&gt;&gt;</span>

<span class="literate-tag-name">&lt;&lt;initialize color definitions&gt;&gt;</span>

sc.doc.Views.EnableRedraw(<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>)









lib_path = <span class="hljs-string">&quot;e:/dev/brickdat/ldraw&quot;</span>

prepare_parts_dictionary()
prepare_idefs_dictionary()
load_colors()





fl : Path = vfiles[<span class="hljs-string">&quot;885-1.mpd&quot;</span>]
load_model(fl)

refresh()

sc.doc.Views.EnableRedraw(<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>)

Rhino.RhinoApp.RunScript(<span class="hljs-string">&quot;ZEA&quot;</span>, <span class="hljs-literal">False</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)

</code></pre>

</div>
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
</script>
</body>
</html>