#! python3

# DO NOT EDIT THIS FILE DIRECTLY. This is generated from a literate program of
# this script with the help of the Literate Programming extension for Visual
# Studio code written by Nathan Letwory
#
#
#
# Or you can read the rendered book at https://jesterking.github.io/literate
#

import scriptcontext as sc
import math

import Rhino

from Rhino.Geometry import Transform, Mesh, Vector3f, Point3f
from Rhino.Display import Color4f
from Rhino.DocObjects import ObjectAttributes, ObjectMaterialSource
from Rhino.Render import ChildSlotNames, ContentUuids, RenderContentType

PbrNames = ChildSlotNames.PhysicallyBased
rhmath = Rhino.RhinoMath

from System.IO import DirectoryInfo, Directory, File, FileInfo
from System.IO import EnumerationOptions, SearchOption

from pathlib import Path

# Globals
parts = dict()
idefs = dict()
ldr_parts = dict() # virtual files from .mpd
materials = dict()
vertidx = 0

def refresh():
    sc.doc.Views.Redraw()
    Rhino.RhinoApp.Wait()

class LegoXform:
    def __init__(self, data : str):
        data = data.strip()
        if len(data) > 0:
            try:
                d = [float(f) for f in data.split()[2:14]]
                self.x = d[0]
                self.y = d[1]
                self.z = d[2]
                self.a = d[3]
                self.b = d[4]
                self.c = d[5]
                self.d = d[6]
                self.e = d[7]
                self.f = d[8]
                self.g = d[9]
                self.h = d[10]
                self.i = d[11]
                xform : Transform = Transform.Identity
                xform.M00 = self.a
                xform.M01 = self.b
                xform.M02 = self.c
                xform.M03 = self.x
                xform.M10 = self.d
                xform.M11 = self.e
                xform.M12 = self.f
                xform.M13 = self.y
                xform.M20 = self.g
                xform.M21 = self.h
                xform.M22 = self.i
                xform.M23 = self.z
                self.xform = xform
            except Exception as e:
                self.xform = Transform.Identity
        else:
            self.xform = Transform.Identity

    def set_xform(self, xform):
        self.xform = xform

    def transform_point(self, u : float, v : float, w : float):
        p = Point3f(u, v, w)
        p.Transform(self.xform)
        return [p.X, p.Y, p.Z]

    def get_xform(self):
        return self.xform


rhino_orient = LegoXform("")
rhino_orient.set_xform(
    Transform.Rotation(
        rhmath.ToRadians(-90.0),
        Vector3f.XAxis,
        Point3f.Origin
    )
)
id_xform = LegoXform("")

def clean_name(part_name):
    part_name = part_name.removesuffix(".dat")
    part_name = part_name.removesuffix(".DAT")
    part_name = part_name.removesuffix(".ldr")
    part_name = part_name.removesuffix(".LDR")
    return part_name

def prepare_parts_dictionary():
    lib_path = "/Users/jesterking/Documents/brickdat/ldraw"
    #lib_path = "e:/dev/brickdat/ldraw"
    library_path : Path = Path(lib_path)
    library_path_net : DirectoryInfo = DirectoryInfo(lib_path)
    all_parts_net = library_path_net.EnumerateFiles("*", SearchOption.AllDirectories)
    for p in all_parts_net:
        fn = Path(p.FullName)
        parts[p.Name] = fn
        parts[f"{fn.parent.name}\\{p.Name}"] = fn

def prepare_idefs_dictionary():
    for idef in sc.doc.InstanceDefinitions:
        idefs[idef.Name] = idef

def update_idefs_dictionary(part_name):
    idef_part_name = clean_name(part_name)
    idef = sc.doc.InstanceDefinitions.Find(idef_part_name)
    if idef:
        idefs[idef_part_name] = idef
        return idef
    return None

def apply_transforms(v, xforms):
    for xform in xforms:
        v = xform.transform_point(*v)
    return v

def collate_transforms(xforms):
   xform = Transform.Identity
   for _xform in xforms:
       xform = xform * _xform.get_xform()

   return xform

def add_poly(m : Mesh, cmd : str, xforms : list):
    global vertidx
    stride = 3
    start = 2
    vertices = int(cmd[0])
    elements = vertices * stride
    to = start + vertices * stride
    d = cmd.split()[start:to]
    try:
        d = [float(f) for f in d]
    except Exception:
        return
    for i in range(0, elements, stride):
        V = apply_transforms(d[i:i+stride], xforms)
        m.Vertices.Add(*V)
        vertidx = vertidx + 1
    if vertices == 4:
        m.Faces.AddFace(vertidx - 4, vertidx - 3, vertidx - 2, vertidx - 1)
    elif vertices == 3:
        m.Faces.AddFace(vertidx - 3, vertidx - 2, vertidx - 1)

def get_part(part_name : str):
    global parts, ldr_parts

    part_name = part_name.replace('/', '\\')

    if part_name in parts:
        return parts[part_name]

    if part_name in ldr_parts:
        return ldr_parts[part_name]

    raise Exception(f"Part file not found: {part_name}")


def read_data(part):
    if isinstance(part, Path):
        with part.open(encoding="utf-8") as f:
            cmds = [l.strip() for l in f.readlines()]
            return cmds
    elif isinstance(part, list):
        return part

def load_part(part, m : Mesh, xforms : list):
    cmds = []
    cmds = read_data(part)

    cmds = [l for l in cmds if len(l)>0]
    for cmd in cmds:
        if cmd.startswith('1'):
            d = cmd.split()
            xform = LegoXform(cmd)
            prt = ' '.join(d[14:])
            _xforms = [xform] + xforms[:]
            try:
                part_file = get_part(prt)
            except Exception:
                print(f"\tERR: Failed getting part {prt}, skipping")
                continue
            load_part(part_file, m, _xforms)
        elif cmd.startswith('3') or cmd.startswith('4'):
            add_poly(m, cmd, xforms)

def get_part_idef(prt):
    p = Path(prt)
    pname = clean_name(p.name)
    if pname in idefs:
        return idefs[pname]

    return None

def contains_poly_commands(cmds):
    for cmd in cmds:
        if len(cmd) == 0: continue
        if cmd[0] in ("2", "3", "4", "5"):
            return True

    return False

def load_model_part(part, xforms : list):
    cmds = []
    cmds = read_data(part)

    cmds = [l for l in cmds if len(l)>0]
    for cmd in cmds:
        if cmd.startswith('1'):
            d = cmd.split()
            color_code = d[1]
            materials[color_code].create_render_material()
            rm = materials[color_code].render_material
            xform = LegoXform(cmd)
            prt = ' '.join(d[14:])
            _xforms = xforms[:] + [xform]

            obattr = ObjectAttributes()
            obattr.Name = clean_name(prt)
            obattr.Visible = True
            obattr.MaterialSource = ObjectMaterialSource.MaterialFromObject
            obattr.RenderMaterial = rm

            if prt.lower().endswith(".ldr"):
                ldr_file = get_part(prt)
                if contains_poly_commands(ldr_file):
                    add_part(prt)
                    idef = update_idefs_dictionary(prt)
                    if idef != None:
                        xform = collate_transforms(_xforms)
                        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                    else:
                        print(f"Couldn't add part {prt}")
                else:
                    load_model_part(ldr_file, _xforms)
            else:
                idef = get_part_idef(prt)
                xform = collate_transforms(_xforms)
                if idef != None:
                    sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                else:
                    #part = get_part(prt)
                    add_part(prt)
                    idef = update_idefs_dictionary(prt)
                    if idef != None:
                        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                    else:
                        print(f"Failed to add part {prt}")

            refresh()


def load_model(model : Path):
    with model.open(encoding="utf-8") as f:
        lines = [l.strip() for l in f.readlines()]

    FILE_START = '0 FILE '
    first_file = ''
    if model.suffix.lower() == '.mpd':
        # parse file into virtual, read files
        cur_file = ''
        file_data = []
        for l in lines:
            if l.startswith(FILE_START):
                if cur_file != '':
                    ldr_parts[cur_file] = file_data
                if cur_file == '':
                    first_file = l[len(FILE_START):]

                cur_file = l[len(FILE_START):]
                file_data = [l]
            else:
                file_data.append(l)
        ldr_parts[cur_file] = file_data # last file
    start_part = get_part(first_file)

    load_model_part(start_part, [rhino_orient])

def find_part_names():
    parts_folder_name = "/Users/jesterking/Documents/brickdat/ldraw/parts"
    #parts_folder_name = "e:/dev/brickdat/ldraw/parts"
    parts_folder = DirectoryInfo(parts_folder_name)
    part_files = parts_folder.EnumerateFiles("*.dat", SearchOption.TopDirectoryOnly)
    part_names = [pf.Name for pf in part_files]
    return part_names


def add_part(part_name : str):
    global vertidx
    vertidx = 0
    #print(f"Loading {part_name}")
    name = clean_name(part_name)

    existing_idef = sc.doc.InstanceDefinitions.Find(name)
    if existing_idef:
        print(f"\tSkipping {part_name}")
        return
    mesh = Mesh()
    obattr = ObjectAttributes()

    obattr.Name = name
    obattr.Visible = True
    obattr.MaterialSource = ObjectMaterialSource.MaterialFromParent

    load_part(get_part(part_name), mesh, [id_xform])
    mesh.Normals.ComputeNormals()
    mesh.Compact()

    if mesh.Vertices.Count > 0 and mesh.Faces.Count > 0:
        sc.doc.InstanceDefinitions.Add(obattr.Name, "", Point3f.Origin, mesh, obattr)

def adjust_color_cmd(cmd):
    cmd = cmd.replace("MATERIAL GLITTER", "MATERIAL_GLITTER")
    cmd = cmd.replace("MATERIAL SPECKLE", "MATERIAL_SPECKLE")
    return cmd

pbr_guid = ContentUuids.PhysicallyBasedMaterialType

class LegoMaterial:
    def __init__(self, props, extra = None):
        self.properties = props
        self.name = props["COLOUR"]
        self.extra = extra
        self.render_material = None

    def _get_color4f(self, colstr):
        colstr = colstr[1:]
        r = int(colstr[0:2], 16) / 255.0
        g = int(colstr[2:4], 16) / 255.0
        b = int(colstr[4:6], 16) / 255.0
        return Color4f(r, g, b, 1.0)

    def _alpha(self, alphastr):
        alpha = 1.0 - (float(alphastr) / 255.0)
        return alpha

    def get_render_material(self):
        if self.render_material == None:

            raise Exception(f"Material non-existant: {self.name}")
        return self.render_material

    def create_render_material(self):
        for rm in sc.doc.RenderMaterials:
            if rm.Name == self.name:
                self.render_material = rm
                return
        pbr_rm = RenderContentType.NewContentFromTypeId(pbr_guid)
        _basecolor = self._get_color4f(self.properties["VALUE"])
        pbr_rm.SetParameter(PbrNames.BaseColor, _basecolor)

        _opacity = 1.0
        if "ALPHA" in self.properties:
            _opacity = self._alpha(self.properties["ALPHA"])
        pbr_rm.SetParameter(PbrNames.Opacity, _opacity)

        _metallic = 0.0
        if self.extra in ("METAL", "CHROME"):
            _metallic = 1.0
        pbr_rm.SetParameter(PbrNames.Metallic, _metallic)

        pbr_rm.Name = self.name
        self.render_material = pbr_rm
        sc.doc.RenderMaterials.Add(pbr_rm)


def load_colors():
    colorldr = get_part("LDConfig.ldr")
    cmds = read_data(colorldr)
    COLOR_CMD = "0 !COLOUR "
    TO_REMOVE = "0 !"
    for cmd in cmds:
        if cmd.startswith(COLOR_CMD):
            properties = dict()
            cmd = cmd[len(TO_REMOVE):]
            cmd = adjust_color_cmd(cmd)
            cmd_split = cmd.split()
            keyvalue_count = len(cmd_split) // 2
            extra = len(cmd_split) % 2
            if extra == 1:
                extra = cmd_split[-1]
            else:
                extra = None
            for i in range(0, keyvalue_count*2, 2):
                properties[cmd_split[i]] = cmd_split[i+1]
            lego_material = LegoMaterial(properties, extra)
            materials[properties["CODE"]] = lego_material
    print("Colors read")


def load_all_parts_as_idefs():
    fns = find_part_names()
    goforit = fns
    print(f"Loading {len(goforit)} parts")

    total = len(goforit)
    counter = 1
    for prt in goforit:
        print(f"{counter}/{total} : {prt}")
        add_part(prt)
        refresh()
        counter = counter + 1

#load_all_parts_as_idefs()

sc.doc.Views.EnableRedraw(False, False, False)

prepare_parts_dictionary()
prepare_idefs_dictionary()
load_colors()

fl : Path = parts["885-1.mpd"]
#fl : Path = parts["8836-1.mpd"]
#fl : Path = parts["10019-1.mpd"]
#fl : Path = parts["10030-1.mpd"]
#fl : Path = parts["10143-1.mpd"]
#fl : Path = parts["10252-1.mpd"]
#fl : Path = parts["mytester.mpd"]
#fl : Path = parts["75969-1.mpd"]
#fl : Path = parts["31048-1.mpd"]
#fl : Path = parts["3063-1.mpd"]
#fl : Path = parts["42064-1.mpd"]
load_model(fl)

refresh()

sc.doc.Views.EnableRedraw(True, True, True)

print("Done")


#print(f"Read {len(goforit)} parts")




