#! python3

# DO NOT EDIT THIS FILE DIRECTLY. This is generated from a literate program of
# this script with the help of the Literate Programming extension for Visual
# Studio Code written by Nathan Letwory.
#
# If you want to contribute install the Literate Programming extension for
# Visual Studio Code from
# https://marketplace.visualstudio.com/items?itemName=jesterking.literate and
# edit the .literate files in this repository instead.
#
# The source code repository is at https://github.com/jesterKing/rhildraw
#
# The code, literate and generated, is licensed under MIT license. See
# https://github.com/jesterKing/rhildraw/LICENSE for more details.
#
# Or you can read the HTML rendered documentation at
# https://jesterking.github.io/rhildraw
#

import traceback
import sys
import scriptcontext as sc
import math

from typing import Mapping, List

import Rhino

from Rhino.Geometry import Transform, Mesh, Vector3f, Point3f, MeshFace
from Rhino.Display import Color4f
from Rhino.DocObjects import ObjectAttributes, ObjectMaterialSource
from Rhino.DocObjects import InstanceDefinition
from Rhino.Render import ChildSlotNames, ContentUuids, RenderContentType

PbrNames = ChildSlotNames.PhysicallyBased
rhmath = Rhino.RhinoMath

from System.IO import DirectoryInfo, Directory, File, FileInfo
from System.IO import EnumerationOptions, SearchOption

from pathlib import Path
from enum import Enum

class Winding(Enum):
    CW = 1
    CCW = 2

    def is_ccw(self):
        return self == Winding.CCW
        #return self.value == 2

    def is_cw(self):
        return self == Winding.CW
        # return self.value == 1

    def flip(self):
        return Winding.CW if self == Winding.CCW else Winding.CCW

class LDrawFile:
    def __init__(self, path : Path, data : List[str] = []):
        self.commands = data
        self.path = path
        self.name = path.name
        self.suffix = path.suffix
        self.pname = f"{path.parent.name}\\{self.name}"
        self.ppname = f"{path.parent.parent.name}\\{path.parent.name}\\{self.name}"
    def get_commands(self):
        if len(self.commands)==0 and not self.is_3dm():
            with self.path.open(encoding="utf-8") as f:
                cmds = [l.strip() for l in f.readlines()]
                cmds = [c for c in cmds if len(c) > 0]
                self.commands = cmds
    
        return self.commands

    def __repr__(self):
        if self.is_3dm():
            return f"LDrawFile '{self.name}', a Rhino 3d file."
        else:
            return f"LDrawFile '{self.name}', {len(self.get_commands())} commands."

    def is_ccw_winding(self):
        if self.is_3dm():
            return
        cmds = self.get_commands()
        for cmd in cmds:
            if cmd.startswith('0') and 'BFC' in cmd and 'CCW' in cmd:
                return True

        return False

    def is_3dm(self):
        return self.suffix == '.3dm'
class LDrawMaterial:
    def __init__(self, props):
        self.properties = props
        self.name = props["COLOUR"]
        self.render_material = None

    def _get_color4f(self, colstr):
        colstr = colstr[1:]
        r = int(colstr[0:2], 16) / 255.0
        g = int(colstr[2:4], 16) / 255.0
        b = int(colstr[4:6], 16) / 255.0
        return Color4f(r, g, b, 1.0)

    def _alpha(self, alphastr):
        alpha = 1.0 - (float(alphastr) / 255.0)
        return alpha

    def get_render_material(self):
        if self.render_material == None:

            raise Exception(f"Material non-existant: {self.name}")
        return self.render_material

    def create_render_material(self):
        for rm in sc.doc.RenderMaterials:
            if rm.Name == self.name:
                self.render_material = rm
                return
        pbr_rm = RenderContentType.NewContentFromTypeId(pbr_guid)

        _basecolor = self._get_color4f(self.properties["VALUE"])

        _roughness = 0.2
        _metallic = 0.0
        _opacity = 1.0

        if "ALPHA" in self.properties:
            _opacity = self._alpha(self.properties["ALPHA"])
            _roughness = 0.03

        if "METAL" in self.properties or "CHROME" in self.properties:
            _metallic = 1.0
            _roughness = 0.03
        if "MATTE_METALLIC" in self.properties:
            _metallic = 1.0
            _roughness = 0.3

        pbr_rm.SetParameter(PbrNames.BaseColor, _basecolor)
        pbr_rm.SetParameter(PbrNames.Opacity, _opacity)
        pbr_rm.SetParameter(PbrNames.Metallic, _metallic)
        pbr_rm.SetParameter(PbrNames.Roughness, _roughness)

        pbr_rm.Name = self.name
        self.render_material = pbr_rm
        sc.doc.RenderMaterials.Add(pbr_rm)



# Globals
vfiles: Mapping[str, LDrawFile]= dict()
idefs : Mapping[str, InstanceDefinition]= dict()
materials : Mapping[str, LDrawMaterial]= dict()
vertidx = 0
pbr_guid = ContentUuids.PhysicallyBasedMaterialType

def refresh():
    sc.doc.Views.Redraw()
    Rhino.RhinoApp.Wait()

class LegoXform:
    def __init__(self, data : str):
        data = data.strip()
        if len(data) > 0:
            try:
                d = [float(f) for f in data.split()[2:14]]
                self.x = d[0]
                self.y = d[1]
                self.z = d[2]
                self.a = d[3]
                self.b = d[4]
                self.c = d[5]
                self.d = d[6]
                self.e = d[7]
                self.f = d[8]
                self.g = d[9]
                self.h = d[10]
                self.i = d[11]
                xform : Transform = Transform.Identity
                xform.M00 = self.a
                xform.M01 = self.b
                xform.M02 = self.c
                xform.M03 = self.x
                xform.M10 = self.d
                xform.M11 = self.e
                xform.M12 = self.f
                xform.M13 = self.y
                xform.M20 = self.g
                xform.M21 = self.h
                xform.M22 = self.i
                xform.M23 = self.z
                self.xform = xform
            except Exception as e:
                self.xform = Transform.Identity
        else:
            self.xform = Transform.Identity

    def set_xform(self, xform):
        self.xform = xform

    def transform_point(self, u : float, v : float, w : float):
        p = Point3f(u, v, w)
        p.Transform(self.xform)
        return [p.X, p.Y, p.Z]

    def get_xform(self):
        return self.xform


rhino_orient = LegoXform("")
rhino_orient.set_xform(
    Transform.Rotation(
        rhmath.ToRadians(-90.0),
        Vector3f.XAxis,
        Point3f.Origin
    )
)
id_xform = LegoXform("")

def clean_name(part_name):
    part_name = part_name.removesuffix(".dat")
    part_name = part_name.removesuffix(".DAT")
    part_name = part_name.removesuffix(".ldr")
    part_name = part_name.removesuffix(".LDR")
    return part_name

def prepare_parts_dictionary():
    global lib_path, vfiles
    library_path : Path = Path(lib_path)
    library_path_net : DirectoryInfo = DirectoryInfo(lib_path)
    all_parts_net = library_path_net.EnumerateFiles("*", SearchOption.AllDirectories)
    for p in all_parts_net:
        fn = Path(p.FullName)
        if fn.suffix.lower() in ('.txt', '.zip', '.exe', '.DS_Store'):
            continue

        if len(fn.suffix) > 0 and fn.suffix.lower() in ('.3dm'):
            print(f'Adding {fn}')

        ldrawfile = LDrawFile(fn)
        vfiles[ldrawfile.name] = ldrawfile
        vfiles[ldrawfile.pname] = ldrawfile

        if ldrawfile.is_3dm():
            print(f'\t{ldrawfile} .. [{ldrawfile.name}] :: {vfiles[ldrawfile.name]}')

def prepare_idefs_dictionary():
    for idef in sc.doc.InstanceDefinitions:
        idefs[idef.Name] = idef

def update_idefs_dictionary(part_name):
    idef_part_name = clean_name(part_name)
    idef = sc.doc.InstanceDefinitions.Find(idef_part_name)
    if idef:
        idefs[idef_part_name] = idef
        return idef
    return None

def apply_transforms(v, xforms):
    for xform in xforms:
        v = xform.transform_point(*v)
    return v

def collate_transforms(xforms):
   xform = Transform.Identity
   for _xform in xforms:
       xform = xform * _xform.get_xform()

   return xform

def add_poly(m : Mesh, cmd : str, xforms : list, from_winding = Winding.CCW, winding = Winding.CCW):
    global vertidx
    stride = 3
    start = 2
    vertices = int(cmd[0])
    elements = vertices * stride
    to = start + vertices * stride
    d = cmd.split()[start:to]
    try:
        d = [float(f) for f in d]
    except Exception:
        return
    #print(f"Add poly with {vertices} vertices with from_winding {from_winding} -> winding {winding}")
    vidxs = list()
    for i in range(0, elements, stride):
        V = apply_transforms(d[i:i+stride], xforms)
        m.Vertices.Add(*V)
        vidxs.append(vertidx)
        vertidx += 1
    
    if len(vidxs) == 4 and from_winding == winding:
        #print(f"A: {vidxs}")
        rev = vidxs[1:]
        rev.reverse()
        vidxs = [vidxs[0]] + rev
        #print(f"B: {vidxs}")
    
    if vertices == 4:
        mf = MeshFace(vidxs[0], vidxs[1], vidxs[2], vidxs[3])
    elif vertices == 3:
        mf = MeshFace(vidxs[0], vidxs[1], vidxs[2])
    if from_winding != winding and False:
        #print(f"\tFlipping {mf.ToString()}")
        mf = mf.Flip()
        #print(f"\t\tFlipped {mf.ToString()}")
    m.Faces.AddFace(mf)
    

first_time = True
def get_ldraw_file(part_name : str) -> LDrawFile:
    global vfiles, first_time

    part_name = part_name.replace('/', '\\')

    part_3dm = Path(part_name).with_suffix('.3dm').name

    print(f"...searching for [{part_3dm}]")

    if "springMesh" in part_3dm:
        pass

    if part_3dm in vfiles.keys():
        print(f"\t found {part_3dm}")
        return vfiles[part_3dm]

    if part_name in vfiles.keys():
        return vfiles[part_name]

    raise Exception(f"Part file not found: {part_name}")


def load_part(part : LDrawFile, m : Mesh, xforms : list, override_invert_faces = False):
    cmds = part.get_commands()
    invert_faces = False
    direction = Winding.CCW if part.is_ccw_winding() else Winding.CW
    if part.is_ccw_winding() and not override_invert_faces:
        invert_faces = True
    elif part.is_ccw_winding() and override_invert_faces:
        invert_faces = False
    elif override_invert_faces and not part.is_ccw_winding():
        invert_faces = True

    #print(f"load_part {part.ppname}, {direction}, {override_invert_faces}. {invert_faces}")

    invert_next = False
    for cmd in cmds:
        if is_invert_cmd(cmd):
            #print(f"\tInverting next cmd")
            invert_next = True
            continue
        if cmd.startswith('1'):
            d = cmd.split()
            xform = LegoXform(cmd)
            prt = ' '.join(d[14:])
            _xforms = [xform] + xforms[:]
            try:
                part_file = get_ldraw_file(prt)
            except Exception:
                print(f"\tERR: Failed getting part {prt}, skipping")
                continue
            load_part(part_file, m, _xforms, invert_next)
        elif cmd.startswith('3') or cmd.startswith('4'):
            direction_to_use = direction
            if override_invert_faces:
                direction_to_use = direction.flip()
            add_poly(m, cmd, xforms, direction, direction.flip() if override_invert_faces else direction) # DEBUG, not invert_faces if invert_next else invert_faces)
        invert_next = False

def get_part_idef(prt):
    p = Path(prt)
    pname = clean_name(p.name)
    if pname in idefs:
        return idefs[pname]

    return None

def is_invert_cmd(cmd):
    return cmd.startswith('0') and 'BFC' in cmd and 'INVERTNEXT' in cmd

def contains_poly_commands(cmds):
    for cmd in cmds:
        if len(cmd) == 0: continue
        if cmd[0] in ("2", "3", "4", "5"):
            return True

    return False

def blockinstance_for_idef(prt, _xforms, obattr, override_invert_faces=False):
    idef = get_part_idef(prt)
    xform = collate_transforms(_xforms)
    if idef == None:
        add_part(prt, override_invert_faces)
        idef = update_idefs_dictionary(prt)
    if idef != None:
        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
    else:
        print(f"Failed to add part {prt}")

def load_model_part(part : LDrawFile, xforms : list, override_invert_faces = False):
    cmds = []
    cmds = part.get_commands()

    direction = Winding.CW
    flipped = False

    cmds = [l for l in cmds if len(l)>0]
    if part.is_ccw_winding():
        #print(f"BFC CCW detected")
        direction = Winding.CCW

    for cmd in cmds:

        if is_invert_cmd(cmd):
            #print(f"BFC INVERTNEXT detected setting direction {direction} to {not direction}")
            direction = not direction
            override_invert_faces = True
            flipped = True
            continue
        if cmd.startswith('1'):
            d = cmd.split()
            color_code = d[1]
            materials[color_code].create_render_material()
            rm = materials[color_code].render_material
            xform = LegoXform(cmd)
            prt = ' '.join(d[14:])
            _xforms = xforms[:] + [xform]

            obattr = ObjectAttributes()
            obattr.Name = clean_name(prt)
            obattr.Visible = True
            obattr.MaterialSource = ObjectMaterialSource.MaterialFromObject
            obattr.RenderMaterial = rm

            if prt.lower().endswith(".ldr"):
                ldr_file = get_ldraw_file(prt)
                if contains_poly_commands(ldr_file.get_commands()):
                    add_part(prt, override_invert_faces)
                    idef = update_idefs_dictionary(prt)
                    if idef != None:
                        xform = collate_transforms(_xforms)
                        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                    else:
                        print(f"Couldn't add part {prt}")
                elif ldr_file.is_3dm():
                    blockinstance_for_idef(prt, _xforms, obattr, override_invert_faces)
                else:
                    load_model_part(ldr_file, _xforms, override_invert_faces)
            else:
                blockinstance_for_idef(prt, _xforms, obattr, override_invert_faces)
                """
                idef = get_part_idef(prt)
                xform = collate_transforms(_xforms)
                if idef == None:
                    add_part(prt, override_invert_faces)
                    idef = update_idefs_dictionary(prt)
                if idef != None:
                    sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)
                else:
                    print(f"Failed to add part {prt}")
                """

            # flip reset
            if flipped:
                #print(f"BFC INVERTNEXT done, setting direction {direction} to {not direction}")
                direction = not direction
                flipped = False
            refresh()

def add_virtual_file(model : Path, filename : str, data : List[str]):
    global vfiles
    virtual_file_path = model.parent / 'virtual' / filename
    virtual_file = LDrawFile(virtual_file_path, data)
    vfiles[virtual_file.name] = virtual_file
    vfiles[virtual_file.pname] = virtual_file


def load_model(model : LDrawFile):
    lines = model.get_commands()

    FILE_START = '0 FILE '
    first_file = ''
    if model.suffix.lower() == '.mpd':
        # parse file into virtual, read files
        cur_file = ''
        file_data = []
        for l in lines:
            if l.startswith(FILE_START):
                if cur_file != '':
                    add_virtual_file(model.path, cur_file, file_data)
                if cur_file == '':
                    first_file = l[len(FILE_START):]
                cur_file = l[len(FILE_START):]
                file_data = [l]
            else:
                file_data.append(l)
        add_virtual_file(model.path, cur_file, file_data) # last file
    elif model.suffix.lower() == '.ldr':
        first_file = model.name
    start_part = get_ldraw_file(first_file)

    load_model_part(start_part, [rhino_orient])


def add_part(part_name : str, invert_faces = False):
    global vertidx
    vertidx = 0
    name = clean_name(part_name)

    print(f"adding part {part_name} ({name})")

    existing_idef = sc.doc.InstanceDefinitions.Find(name)
    if existing_idef:
        print(f"\tSkipping {part_name}, instance already created")
        return
    else:
        pass #print(f"\tLoading [{part_name}]")

    ldraw_file = get_ldraw_file(part_name)

    if ldraw_file.is_3dm():
        print(f"... reading 3dm file {ldraw_file.path}")
        f3dm = Rhino.FileIO.File3dm.Read(f'{ldraw_file.path}')
        obs_to_add = list()
        attrs_to_add = list()
        for ob in f3dm.Objects:
            if ob.Geometry.ObjectType == Rhino.DocObjects.ObjectType.InstanceReference:
                continue
            obs_to_add.append(ob.Geometry)
            attrs_to_add.append(ob.Attributes)

        obattr = ObjectAttributes()
        obattr.Name = name
        obattr.Visible = True
        obattr.MaterialSource = ObjectMaterialSource.MaterialFromParent
        print(sc.doc.InstanceDefinitions.Add(
            f'{name}',
            f'High-definition Rhino version of {name}.',
            Rhino.Geometry.Point3d.Origin,
            obs_to_add,
            attrs_to_add
        ))
        f3dm.Dispose()
    else:
        mesh = Mesh()
        obattr = ObjectAttributes()

        obattr.Name = name
        obattr.Visible = True
        obattr.MaterialSource = ObjectMaterialSource.MaterialFromParent

        load_part(ldraw_file, mesh, [id_xform], invert_faces)
        mesh.Weld(math.radians(50))
        mesh.Normals.ComputeNormals()
        mesh.Compact()

        if mesh.Vertices.Count > 0 and mesh.Faces.Count > 0:
            sc.doc.InstanceDefinitions.Add(obattr.Name, "", Point3f.Origin, mesh, obattr)

def load_colors():
    colorldr = get_ldraw_file("LDConfig.ldr")
    cmds = colorldr.get_commands()
    COLOR_CMD = "0 !COLOUR "
    TO_REMOVE = "0 !"
    for cmd in cmds:
        if cmd.startswith(COLOR_CMD):
            properties = dict()
            cmd = cmd[len(TO_REMOVE):]
            cmd_split = cmd.split()
            if len(cmd_split) % 2 == 1:
                cmd_split.append('dummy')
            keyvalue_count = len(cmd_split) // 2
            for i in range(0, keyvalue_count*2, 2):
                properties[cmd_split[i]] = cmd_split[i+1]
            ldraw_material = LDrawMaterial(properties)
            materials[properties["CODE"]] = ldraw_material
    print("Colors read")

#sc.doc.Views.EnableRedraw(False, False, False)

###########################################
## Set path to where your LDraw library and
## model files are. They should be under
## the same main folder
## Use always forward slashes, also for
## folders on Windows
###########################################
lib_path = "/Users/jesterking/Documents/brickdat/ldraw"
#lib_path = "e:/dev/brickdat/ldraw"

prepare_parts_dictionary()
prepare_idefs_dictionary()
load_colors()


#fl : Path = vfiles["885-1.mpd"]
#fl : Path = vfiles["8836-1.mpd"]
#fl : Path = vfiles["10019-1.mpd"]
#fl : Path = vfiles["10030-1.mpd"]
#fl : Path = vfiles["10143-1.mpd"]
#fl : Path = vfiles["75969-1.mpd"]
#fl : Path = vfiles["31048-1.mpd"]
#fl : Path = vfiles["3063-1.mpd"]
fl : Path = vfiles["42064-1.mpd"]


###########################################
## Specify what model to load. Use just the
## file name (including extension)
###########################################
#fl : Path = vfiles["tester.mpd"]
#fl : Path = vfiles["pyramid.ldr"]
#fl : Path = vfiles["10019-1.mpd"]
fl : Path = vfiles["8836-1.mpd"]
#fl : Path = vfiles["885-1.mpd"]

load_model(fl)

refresh()

sc.doc.Views.EnableRedraw(True, True, True)

Rhino.RhinoApp.RunScript("ZEA", False)

print("Done")



